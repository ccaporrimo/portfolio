import { Injectable } from '@angular/core';
import { PortfolioProject, ProjectBasicInfo } from '../interfaces/project.interface';
import { SkillTypeEnum } from '../constants/skill.constants';
import { Companies, ProjectIdEnum } from '../constants/project.constants';
import { DomSanitizer } from '@angular/platform-browser';
import { Year } from './helpers';
import { BehaviorSubject } from 'rxjs';

const S = SkillTypeEnum;
const Id = ProjectIdEnum;

const onlineBookingDescription = `<p>What started off as a self-initiated POC to proof out a better flow and design for the company's Online Booking system turned into an official full team reimplementation tracked in <span app-skill="${S.AzureDevOps}">Azure DevOps</span>. Written in <span app-skill="${S.TypeScript}">TypeScript</span> using the <span app-skill="${S.Angular}">Angular 16</span> framework, we rebuilt the Online Booking SPA from the ground up using a scaffolded architecture that takes advantage of the <span app-skill="${S.RxJs}">RxJs</span> observable pattern. Focusing on clarity, performance, styling using <span app-skill="${S.Scss}">SCSS</span>, and long‑term maintainability. The updated structure emphasizes clean separation of responsibilities, streamlined <span app-skill="${S.NgRx}">NgRx</span> state management, and a more predictable component hierarchy. These improvements not only reduced technical debt but also created a foundation that is easier to extend as new features are introduced.</p>
<p>In the backend, I created new endpoints for the API layer in <span app-skill="${S.CSharp}">C#</span> and the <span app-skill="${S.DotNetCore}">.NET Core</span> framework to allow for legacy Online Booking users to continue usage without impact while vastly improving response time and reducing round-trip calls which also caused race conditions in the <span app-skill="${S.NgRx}">NgRx</span> state management system. By shifting to a more object‑oriented approach, I eliminated large branching logic blocks and replaced them with modular, testable components. This restructuring improved readability, reduced coupling, and strengthened the overall reliability of the system while increasing percieved performance.</p>
<p>Part of the efficiency enhancements included updates to <span app-skill="${S.SqlServer}">Stored Procedure</span> queries, joins, and reduced response object sizes. To enhance security and user experience, I implemented a one‑time‑password authentication flow using <span app-skill="${S.DotNetCore}">.NET Core</span> middleware and prerequest filters along with <span app-skill="${S.Redis}">Redis</span> caching. These additions modernized the login process and provided users with flexible, secure sign‑in options. I also introduced subtle interface animations—including page‑transition effects and calendar fly‑ins—to create a smoother, more polished interaction model throughout the application.</p>
`;

const egiftDescription = `<p>My company's original eGift card system was solid but extremely antequated in structure, technology (built in Angular 5) and UI. A returning enterprise client wary of coming back given their extremely high volume of online gift card transactions triggered a 5-alarm-fire response from leadership. A tiger-team was formed to quickly rebuild the entire eGift system in <span app-skill="${S.Angular}">Angular 16</span> with absolutely no change to the APIs in order to prevent legacy disruptions.</p>
<p>The previous system did not make adequate use of <span app-skill="${S.RxJs}">Reactive patterns, Observables and Subjects</span> which we were able to rearchitect in the new application and properly implement <span app-skill="${S.NgRx}">NgRx state management</span>. In addition, I implemented a complex carousel component that dynamically builds any Angular component type that is passed into it for a seamless, yet efficient, infinite scroll experience making heavy use of <span app-skill="${S.RxJs}">Behavior Subjects and Observables</span>.</p>
<p>Part of the eGift system is choosing from a series of predefined card templates & images or user-uploaded templates. By integrating with <span app-skill="${S.Aws}">S3 storage APIs</span> and using the Canvas API, we were able to enhance both the file upload and the fetch / display experience increasing speed.</p>
`;

const customBrandingDescription = `<p>One of the major pain-points for our clientelle was the confusing Custom Branding interface and its lackluster consumption in end-user facing applications (like Online Booking). On my own initiative, I decided to consolidate the bulky and excessive multi-tab format that had seemingly duplicated settings and to overhaul the persistence architecture. Instead of storing these settings in our monolith relational DB, I used <span app-skill="${S.Aws}">S3 buckets</span> to store a JSON file of the entire settings object. This allowed us to add and remove settings without having to update database entries or middle tier models & logic.</p>
<p>The previous settings maintenance forms were written in AngularJS and had ineffecient and antequated image upload components. I rebuilt the settings screen in <span app-skill="${S.Angular}">Angular 16</span> including numerous multiple-inheritence components. I rebuilt an image upload tool with cropping functionality using JavaScript Blob API (in <span app-skill="${S.TypeScript}">, </span>), <span app-skill="${S.RxJs}">RxJs observables and subjects</span> along with a streamlined set of <span app-skill="${S.DotNetCore}">new endpoints</span> in our <span app-skill="${S.Aws}">S3 API</span> interface.</p>
<p>I also integrated with Google Fonts and created a combination <span app-skill="${S.RxJs}">dropdown/search interface</span> for users to search the entire Google Font catalog and apply it as the main font for the end-user-facing web apps. In addition to this, I rebuilt the "background" component which allows users to upload a background image or use gradients. I added a new feature allowing finer control over the gradients as well as adding the ability for users to <span app-skill="${S.Aws}">upload</span> a seamless tile image that presents as a patterned background.</p>
<p>Finally, I created an embedded live-view of the end-user eGift application that dynamically updated when the user would change any given setting allowing for instantaneous feedback. The live-vew was embedded using an <span app-skill="${S.TypeScript}">iframe</span> communicating with the main app via post-messages. Included with this was also the ability for users to obtain a preview link that would load the eGift site live using the new settings but without exposing them to general users. Only after publishing the changes would the general public see them. I used <span app-skill="${S.Redis}">Redis caching</span> to temporarily store the JSON settings object using a Guid key which is included in the app's URL parameters.</span>
`;

const thisWebsiteDescription = `<p>One of the best ways to show what someone is capable of is by simply doing the thing. I created this website from scratch as an <span app-skill="${S.Angular}">Angular SPA</span> making heavy use of <span app-skill="${S.RxJs}">RxJs and Reactive patterns</span> and a clean, organized codebase. The site reacts to user's browser settings for light / dark theme using a blend of CSS variables and <span app-skill="${S.Scss}">SCSS functions and variables</span></p>
<p>Making use of the <span app-skill="${S.TypeScript}">Animation API</span> to provide flair and style, the site is meant to represent my ability to generate designs, requirements, architecture, and followthru with an elegant and organized codebase. Using a combination of <span app-skill="${S.RxJs}">Observables and Behavior Subjects</span>, I created an infinite scroller to display the different projects I've worked on. I integrated HammerJS gesture library to allow for swipe-scrolling on mobile.</p>
<p>The site is also responsive allowing for desktop and mobile viewing. The desktop site displays usage of <span app-skill="${S.Angular}">named routers</span> to alter one portion of the screen (Skills) using a named route while still viewing the main "Projects" route component. The mobile-version hides the projects scroller in a custom built "side drawer" component. While on mobile, skill basic details are displayed in a modified <span app-skill="${S.Angular}">Angular Material</span> dialog.</p>
`;

const onlineAnalyticsDescription = `<p>Several enterprise clients requested a feature for their franchisees for our client-facing applications. They wanted to be able to track all loctions at a corporate level using their corporate Google Analytics and GTM accounts while they also needed their franchisees to track their individual locations using their own Google accounts. Our client-facing applications were only set up to have either-or <b>not both</b>. I was tasked with allowing location-level accounts to report alongside the corporate-level while also tracking location changes for the corporate level.</p>
<p>I achieved this solution by <span app-skill="${S.CSharp}">renovating the initialization API endpoint</span> for our unified "Customer Portal" platform so that it would return both the Central Office (corporate) account ids as part of the top-level response objects while also including the location-level account ids in a "location settings" object. Separating them allowed us to <span app-skill="${S.GoogleAnalytics}">initialize the Google Analytics and GTM scripts</span> with multiple accounts <i>instead of</i> the settings endpoint simply returning a single set of ids belonging to the lowest level.</p>
<p>Once both sets of ids were available, I had to create a new system to initialize GA and GTM scripts for both ids but also to ascertain when to push data into the data-layer for events that pertained to corporate, franchise, or both. For each category, I created an array of <span app-skill="${S.NgRx}">Actions. Each set would be handled by an Effect</span> and inside the effect, the action type would be ascertained and then call into a new <span app-skill="${S.Angular}">"analytics service"</span> which would push the data into the data-layer. As an additional ask, we needed to provide a way for the business to track by each user and so we hashed the email address and phone number pushing this custom data into the data-layer with every event.</p>
<p>Along with these general changes for all our customer-facing modules, I also implemented from scratch the analytics tracking for the new eGift system. This included tracking the gift card template selection, amount selections, processing card information and completing purchases or abandoning the flow. I made heavy use of the <span app-skill="${S.NgRx}">new infrastructure I created</span> to solve this requirement.</p>
`;

const bookingAgentDesc = `<p>One of the first solo projects that I was put onto as a newly minted Engineer was the Booking Agent. Having been a Business Analyst for the team that handled Security, my lead thought I was a good candidate for this project. Most of the front end work had already been done for a feature called "Call Center" but we needed to extend that functionality. Instead of targeting enterprise-only who might have a "call center" to operate, we wanted to target any multi-location tenant so that they could easily book across locations. Not only that but to manage the data necessary to book appointemnts across locations. The problem was that our security infrastructure wasn't built for dynamically changing locations <i>from within a location</i></p>
<p>My task was to create an infrastructure that would allow users to access this "Booking Agent" screen and select a location from a typeahead list of locations <b>for which they had access</b> and then to refresh the security infrastructure so that all modules of the application would <span app-skillset="${S.CSharp}">apply security settings</span> that the user would've had if they logged into the location they selected in the Agent. This required intercepting the request in the <span app-skill="${S.DotNetCore}">API middleware</span>, performing transformations to the request DTO and then implementing a special session object for impersonation. Then, our session "LocationProvider" needed to be updated to consider if there was an impersonation or not occurring.</p>
<p>The front end security services needed to also be refreshed while also ensuring that the same user logging into another browser window (or even another browser) wouldn't be able to cross-contaminate. As such, I needed to implemented a front-end <span app-skill="${S.TypeScript}">messaging system and local storage solution</span> that would detect if a user started an impersonation session and, if so, to lock the screen if the impersonated location was different from the current location. If the user stopped impersonating on another screen and the locationIds matched up again, we would automatically close the dialog that was locking the screen.</p>
<p>The system architect was under the impression that the security refresh couldn't be done successfully. My implementation made him change his mind and my success in this project paved the way for me to receive more complex full stack assignments.</p>`;

const schedulingDesc = `<p>When I was first moved to be a team lead, there was an ongoing project to reimplement the Employee Scheduling system which had been in flux for almost 2 years. The code had been partially deprecated due to a mid-stream Angular update from v11 to v16 which had some hefty breaking changes. I was tasked with getting the team to complete this project and get it out before it would fall further behind. The team had done a good job given the project constraints, lack of quality requirements and continual reprioritizations. That being said, matters of scale had not been taken into consideration and when we finally pushed the feature into a release candidate branch, the scalability problems began rearing their ugly head.</p>
<p>With only a couple of weeks before go-live, I jumped in to investigate what was causing the slowdowns, screen freezes, and crashes eventually landing upon the new "Day View" which ended up having hundreds of individual div slices for every employee. As soon as the employee list grew to at least a dozen, scrolling thru the list and making changes to the schedule would slow down or crash the page. I implemented a system of batch fetching and removing rows based on proximity to the viewport. By doing this, there were only ever 8 records being rendered in the DOM at any given time. This alleviated the slow downs and crashes from occurring. But the last matter of scale was even more problematic.</p>
<p>Although an unlikely scenario for a spa or salon, some of our businesses could have upward of 1000 employees at a single location. These were "schools" that had several batches of classes with dozens of students in each batch. The scheduling system would get overwhelmed with data on 2-week and month views. I implemented a paging system in a matter of days that solved this problem. The scheduler ended up being one of our most stable features garnering less than 1 bug reported per quarter on average.</p>`

const securityDesc = `<p>The company's client-facing applications secured our client-creation and credit card hosted-page endpoints using the reCAPTCHA system. We implemented this using a combination of <span app-skill="${S.NgRx}">Actions, Effects</span>, and <span app-skill="${S.RxJs}">custom RxJs hooks</span> so that any Effects that would call these API endpoints would just need to add "withRecaptcha()" into the effect pipe and then pass the resulting token into the API request payload. This drastically simplified the process and ensured security and safety for these endpoints that needed to be exposed to Guest roles.</p>
<p>The OIDC authentication flow is another piece of the Security project that I personally implemented in our Customer Portal so that clients could use Google or Facebook to authenticate. I used <span app-skill="${S.DotNetCore}">the Microsoft AspNetCore packages</span> which were easily integrated into the base Startup and AppHost classes which I had implemented in an earlier refactor. In order to ensure the location and tenant were the same from initiating the OIDC flow in our API thru the final HTML response, I <span app-skill="${S.Redis}">cached the original JWT token</span> using a newly created GUID as key and passing the GUID across the response & redirect URIs as a URL param. Also, using DataProtection schemes, I ensured that only requests initiated from our API could conclude in a newly registered client (if no matching client was found from the OAuth credentials)</p>
<p>I wanted to make the solution more generic to allow other apps in our monolith to be able to hook into the OIDC flow without much friction. I implemented a system using <span app-skill="${S.CSharp}">Smart Enums</span> (built using the C# record struct) which is simply defined as the AuthScheme name that would be registered in the Startup process. A series of <span app-skill="${S.CSharp}">constants, extension methods, and helpers</span> automatically configure the auth realm, challenge API endpoints, and redirect URIs in a base OAuth class where the specific response HTML can be overridden by child classes. In essence, if no custom HTML response was needed, all a developer needs to do to add new OIDC providers is to add a new Smart Enum and register the auth provider in their Startup class.</p>
<p>Finally, I used Agentic AI to generate loading screens that would be issued in the OIDC window showing an animation between the SaaS business's logo and Google (or Facebook) as well as an ad-hoc success page using an animated SVG that would get passed back from the final API "Redirect URI" endpoint to the OIDC window and shown to the user before automatically closing.</p>
`

@Injectable({
  providedIn: 'root'
})
export class ProjectService {
  public readonly projects: PortfolioProject[];
  public readonly toggleSlideout$: BehaviorSubject<void>  = new BehaviorSubject<void>(undefined);

  private _basicInfosById: { [id in ProjectIdEnum]: ProjectBasicInfo } = {
    [Id.Analytics]: { effortType: 'solo', timespan: { startDate: new Year(2024), endDate: new Year(2025) }, company: Companies.Meevo },
    [Id.ProfessionalPortfolio]: { effortType: 'solo', timespan: { startDate: new Year(2026) } },
    [Id.OnlineBooking]: { effortType: 'lead', timespan: { startDate: new Year(2025), endDate: new Year(2026) }, company: Companies.Meevo, website: 'https://na2.meevo.com/CustomerPortal/advanced-ob/appointment-details?tenantId=500000&locationId=500001' },
    [Id.EGift]: { effortType: 'team', timespan: { startDate: new Year(2024), endDate: new Year(2025) }, company: Companies.Meevo, website: 'https://na2.meevo.com/CustomerPortal/egift?tenantId=500000&locationId=500001' },
    [Id.Scheduler]: { effortType: 'lead', timespan: { startDate: new Year(2024) }, company: Companies.Meevo },
    [Id.CustomBranding]: { effortType: 'solo', timespan: { startDate: new Year(2024) }, company: Companies.Meevo },
    [Id.Security]: { effortType: 'lead', timespan: { startDate: new Year(2025), endDate: new Year(2026) }, company: Companies.Meevo },
    [Id.BookingAgent]: { effortType: 'solo', timespan: { startDate: new Year(2019), endDate: new Year(2020) }, company: Companies.Meevo }
  }
  
  private _projects: Partial<PortfolioProject>[] = [
    { id: Id.Analytics, title: 'Online Analytics', svgIcon: 'project-analytics', skillIds: [S.Angular, S.NgRx, S.GoogleAnalytics, S.CSharp], description: onlineAnalyticsDescription },
    { id: Id.ProfessionalPortfolio, title: 'This Website', svgIcon: 'this_website', skillIds: [S.Angular, S.RxJs, S.TypeScript, S.Scss, S.AzureDevOps], description: thisWebsiteDescription },
    { id: Id.OnlineBooking, title: 'Online Booking', svgIcon: 'project-online-booking', skillIds: [S.CSharp, S.DotNetCore, S.Angular, S.NgRx, S.RxJs, S.Scss, S.SqlServer, S.Redis, S.AzureDevOps], description: onlineBookingDescription },
    { id: Id.EGift, title: 'eGift Cards', svgIcon: 'project-egift', skillIds: [S.Angular, S.NgRx, S.RxJs, S.Aws, S.Scss], description: egiftDescription },
    { id: Id.Scheduler,  title: 'Scheduling', svgIcon: 'project-schedule-system', skillIds: [S.Angular, S.NgRx, S.RxJs, S.Scss, S.SqlServer], description: schedulingDesc },
    { id: Id.CustomBranding, title: 'Custom Branding', svgIcon: 'project-custom-branding', skillIds: [S.CSharp, S.DotNetCore, S.Redis, S.Angular, S.NgRx, S.RxJs, S.Aws], description: customBrandingDescription },
    { id: Id.Security, title: 'Security', svgIcon: 'project-security-system', skillIds: [S.CSharp, S.DotNetCore, S.Redis, S.AzureDevOps, S.SqlServer], description: securityDesc },
    { id: Id.BookingAgent, title: 'Booking Agent', svgIcon:'project-data-maintenance', skillIds: [S.CSharp, S.DotNetCore, S.SqlServer, S.TypeScript], description: bookingAgentDesc }
  ];

  constructor(private _sanitizer: DomSanitizer) {
    this.projects = this._projects.map(p => ({
      ...p,
      title: p.title ?? '',
      route: '/projects/' + p.id,
      description: p.description && typeof(p.description) == 'string'
        ? this._sanitizer.bypassSecurityTrustHtml(p.description)
        : '',
      basicInfo: this._basicInfosById[p.id as ProjectIdEnum]
    }));
  }

  toggleProjectSlideout() {
    this.toggleSlideout$.next();
  }
}
